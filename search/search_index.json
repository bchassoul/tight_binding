{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentaci\u00f3n de Tight Binding Este proyecto incluye implementaciones del modelo de Tight Binding y versiones paralelizadas para mejorar el rendimiento. Introducci\u00f3n al M\u00e9todo de Tight Binding Descripci\u00f3n del Proyecto El modelo de tight binding (o enlace fuerte) se utiliza para describir la estructura de bandas electr\u00f3nicas en s\u00f3lidos cristalinos. En este proyecto, consideramos una cadena at\u00f3mica infinita con un orbital at\u00f3mico por \u00e1tomo. Conceptos Clave Par\u00e1metro de red : a : La distancia entre celdas unidad. Par\u00e1metro de hopping : t : La probabilidad de que un electr\u00f3n salte de un orbital a su vecino. Combinaci\u00f3n de orbitales at\u00f3micos : Se utiliza la combinaci\u00f3n lineal de orbitales at\u00f3micos para describir el estado del sistema. Ecuaciones Fundamentales El modelo se basa en las siguientes ecuaciones: Donde N es el total de sitios y k es un n\u00famero real en el espacio rec\u00edproco. La matriz hamiltoniana dependiente del par\u00e1metro k se diagonaliza para obtener la energ\u00eda del sistema: Objetivos y Metas Construir la matriz hamiltoniana dependiente del par\u00e1metro (k). Diagonalizar la matriz hamiltoniana para obtener la energ\u00eda del sistema. Utilizar la funci\u00f3n de autovalores para optimizar la diagonalizaci\u00f3n de la matriz. Implementar el algoritmo en Python. Implementar la soluci\u00f3n en paralelo para acelerar el algoritmo y evaluar la aceleraci\u00f3n. Contenidos Uso Resultados","title":"Inicio"},{"location":"#documentacion-de-tight-binding","text":"Este proyecto incluye implementaciones del modelo de Tight Binding y versiones paralelizadas para mejorar el rendimiento.","title":"Documentaci\u00f3n de Tight Binding"},{"location":"#introduccion-al-metodo-de-tight-binding","text":"","title":"Introducci\u00f3n al M\u00e9todo de Tight Binding"},{"location":"#descripcion-del-proyecto","text":"El modelo de tight binding (o enlace fuerte) se utiliza para describir la estructura de bandas electr\u00f3nicas en s\u00f3lidos cristalinos. En este proyecto, consideramos una cadena at\u00f3mica infinita con un orbital at\u00f3mico por \u00e1tomo.","title":"Descripci\u00f3n del Proyecto"},{"location":"#conceptos-clave","text":"Par\u00e1metro de red : a : La distancia entre celdas unidad. Par\u00e1metro de hopping : t : La probabilidad de que un electr\u00f3n salte de un orbital a su vecino. Combinaci\u00f3n de orbitales at\u00f3micos : Se utiliza la combinaci\u00f3n lineal de orbitales at\u00f3micos para describir el estado del sistema.","title":"Conceptos Clave"},{"location":"#ecuaciones-fundamentales","text":"El modelo se basa en las siguientes ecuaciones: Donde N es el total de sitios y k es un n\u00famero real en el espacio rec\u00edproco. La matriz hamiltoniana dependiente del par\u00e1metro k se diagonaliza para obtener la energ\u00eda del sistema:","title":"Ecuaciones Fundamentales"},{"location":"#objetivos-y-metas","text":"Construir la matriz hamiltoniana dependiente del par\u00e1metro (k). Diagonalizar la matriz hamiltoniana para obtener la energ\u00eda del sistema. Utilizar la funci\u00f3n de autovalores para optimizar la diagonalizaci\u00f3n de la matriz. Implementar el algoritmo en Python. Implementar la soluci\u00f3n en paralelo para acelerar el algoritmo y evaluar la aceleraci\u00f3n.","title":"Objetivos y Metas"},{"location":"#contenidos","text":"Uso Resultados","title":"Contenidos"},{"location":"resultados/","text":"Resultados Esta secci\u00f3n presenta los resultados obtenidos al ejecutar los scripts. Implementaci\u00f3n Serial Implementaci\u00f3n Paralela La implementaci\u00f3n paralela se prob\u00f3 con diferentes n\u00fameros de n\u00facleos. A continuaci\u00f3n se presentan los resultados: 1 N\u00facleo 2 N\u00facleos 4 N\u00facleos 8 N\u00facleos","title":"Resultados"},{"location":"resultados/#resultados","text":"Esta secci\u00f3n presenta los resultados obtenidos al ejecutar los scripts.","title":"Resultados"},{"location":"resultados/#implementacion-serial","text":"","title":"Implementaci\u00f3n Serial"},{"location":"resultados/#implementacion-paralela","text":"La implementaci\u00f3n paralela se prob\u00f3 con diferentes n\u00fameros de n\u00facleos. A continuaci\u00f3n se presentan los resultados:","title":"Implementaci\u00f3n Paralela"},{"location":"resultados/#1-nucleo","text":"","title":"1 N\u00facleo"},{"location":"resultados/#2-nucleos","text":"","title":"2 N\u00facleos"},{"location":"resultados/#4-nucleos","text":"","title":"4 N\u00facleos"},{"location":"resultados/#8-nucleos","text":"","title":"8 N\u00facleos"},{"location":"uso/","text":"Uso Esta secci\u00f3n proporciona informaci\u00f3n sobre c\u00f3mo utilizar los scripts proporcionados. tight_binding.py Este script implementa el modelo de Tight Binding de manera serial. import random import numpy as np import matplotlib.pyplot as plt def calcular_estructura_de_bandas ( N , a , t , eps , valores_k ): \"\"\" Calcula la estructura de bandas para un modelo de tight-binding en 1D. Par\u00e1metros: N (int): N\u00famero de orbitales at\u00f3micos. a (float): Espaciado de la red. t (float): Par\u00e1metro de hopping. eps (float): Energ\u00eda en el sitio. valores_k (np.ndarray): Array de valores de k. Retorna: lista de np.ndarray: Lista de arrays de autovalores para cada valor de k. \"\"\" autovalores = [] for k in valores_k : H = np . zeros (( N , N ), dtype = complex ) # T\u00e9rmino de energ\u00eda en el sitio for i in range ( N ): H [ i , i ] = eps # T\u00e9rminos de hopping con condiciones de contorno peri\u00f3dicas for i in range ( N ): H [ i , ( i + 1 ) % N ] = - t * np . exp ( 1 j * k * a ) H [( i + 1 ) % N , i ] = - t * np . exp ( - 1 j * k * a ) evals = np . linalg . eigvalsh ( H ) autovalores . append ( evals ) return autovalores def seleccionar_autovalores_aleatorios ( autovalores ): \"\"\" Selecciona un conjunto arbitrario de autovalores de la estructura de bandas calculada. Par\u00e1metros: autovalores (lista de np.ndarray): Lista de arrays de autovalores para cada valor de k. Retorna: np.ndarray: Array de autovalores seleccionados. \"\"\" indice_aleatorio = random . randint ( 0 , len ( autovalores ) - 1 ) return autovalores [ indice_aleatorio ] def aplicar_condiciones_de_contorno_periodicas ( autovalores ): \"\"\" Aplica condiciones de contorno peri\u00f3dicas de manera que E(-k) = E(k). Par\u00e1metros: autovalores (np.ndarray): Array de autovalores. Retorna: np.ndarray: Array de autovalores con condiciones de contorno peri\u00f3dicas aplicadas. \"\"\" return np . concatenate (( np . flip ( autovalores , 0 ), autovalores ), axis = 0 ) def calcular_banda_analitica ( valores_k , t , eps , a ): return eps - 2 * t * np . cos ( valores_k * a ) def graficar_estructura_de_bandas ( valores_k , banda_numerica , t , eps , a , N ): banda_analitica = calcular_banda_analitica ( valores_k , t , eps , a ) fig , axs = plt . subplots () axs . plot ( valores_k , banda_numerica , 'o' , label = f 'Autovalores de H(k)' ) axs . plot ( valores_k , banda_analitica , label = r '$E(k) = \\epsilon_0 - 2t\\cos(ka)$' , linestyle = '--' , color = 'black' ) axs . set_yticks ([ eps - 2. * t , eps - t , eps , eps + t , eps + 2. * t ]) axs . set_yticklabels ([ '$\\epsilon_0-2t$' , '$\\epsilon_0-t$' , '$\\epsilon_0$' , '$\\epsilon_0+t$' , '$\\epsilon_0+2t$' ]) axs . set_xlabel ( 'k' ) axs . set_ylabel ( 'E(k)' ) axs . set_title ( f 'Modelo de tight-binding con cadena at\u00f3mica de N= { N } celdas' ) axs . legend () axs . grid ( True ) fig . savefig ( 'tight_binding.png' ) # Par\u00e1metros N = 50 # N\u00famero de orbitales at\u00f3micos a = 1 # Espaciado de la red t = 0.5 # Par\u00e1metro de hopping eps = 0.0 # Energ\u00eda en el sitio max_iterations = 2 * N valores_k = np . linspace ( - np . pi / a , np . pi / a , max_iterations ) # Array de valores k # Calcular la estructura de bandas autovalores = calcular_estructura_de_bandas ( N , a , t , eps , valores_k ) # Seleccionar un conjunto arbitrario de autovalores para graficar autovalores_seleccionados = seleccionar_autovalores_aleatorios ( autovalores ) # Aplicar las condiciones de contorno peri\u00f3dicas autovalores_con_ccp = aplicar_condiciones_de_contorno_periodicas ( autovalores_seleccionados ) # Graficar la estructura de bandas graficar_estructura_de_bandas ( valores_k , autovalores_con_ccp , t , eps , a , N ) tight_binding_parallel.py Este script implementa el modelo de Tight Binding de manera paralela utilizando multiprocessing. import random import numpy as np import matplotlib.pyplot as plt from multiprocessing import Pool , cpu_count import argparse import time def calcular_estructura_de_bandas_para_k ( args ): k , N , a , t , eps = args H = np . zeros (( N , N ), dtype = complex ) # T\u00e9rmino de energ\u00eda en el sitio for i in range ( N ): H [ i , i ] = eps # T\u00e9rminos de hopping con condiciones de contorno peri\u00f3dicas for i in range ( N ): H [ i , ( i + 1 ) % N ] = - t * np . exp ( 1 j * k * a ) H [( i + 1 ) % N , i ] = - t * np . exp ( - 1 j * k * a ) evals = np . linalg . eigvalsh ( H ) return evals def calcular_estructura_de_bandas ( N , a , t , eps , valores_k , num_cores ): \"\"\" Calcula la estructura de bandas para un modelo de tight-binding en 1D. Par\u00e1metros: N (int): N\u00famero de orbitales at\u00f3micos. a (float): Espaciado de la red. t (float): Par\u00e1metro de hopping. eps (float): Energ\u00eda en el sitio. valores_k (np.ndarray): Array de valores de k. num_cores (int): N\u00famero de n\u00facleos a utilizar para la paralelizaci\u00f3n. Retorna: lista de np.ndarray: Lista de arrays de autovalores para cada valor de k. \"\"\" with Pool ( num_cores ) as p : autovalores = p . map ( calcular_estructura_de_bandas_para_k , [( k , N , a , t , eps ) for k in valores_k ]) return autovalores def seleccionar_autovalores_aleatorios ( autovalores ): \"\"\" Selecciona un conjunto arbitrario de autovalores de la estructura de bandas calculada. Par\u00e1metros: autovalores (lista de np.ndarray): Lista de arrays de autovalores para cada valor de k. Retorna: np.ndarray: Array de autovalores seleccionados. \"\"\" indice_aleatorio = random . randint ( 0 , len ( autovalores ) - 1 ) return autovalores [ indice_aleatorio ] def aplicar_condiciones_de_contorno_periodicas ( autovalores ): \"\"\" Aplica condiciones de contorno peri\u00f3dicas de manera que E(-k) = E(k). Par\u00e1metros: autovalores (np.ndarray): Array de autovalores. Retorna: np.ndarray: Array de autovalores con condiciones de contorno peri\u00f3dicas aplicadas. \"\"\" return np . concatenate (( np . flip ( autovalores , 0 ), autovalores ), axis = 0 ) def calcular_banda_analitica ( valores_k , t , eps , a ): return eps - 2 * t * np . cos ( valores_k * a ) def graficar_estructura_de_bandas ( valores_k , banda_numerica , t , eps , a , N , num_cores ): banda_analitica = calcular_banda_analitica ( valores_k , t , eps , a ) fig , axs = plt . subplots () axs . plot ( valores_k , banda_numerica , 'o' , label = f 'Autovalores de H(k)' ) axs . plot ( valores_k , banda_analitica , label = r '$E(k) = \\epsilon_0 - 2t\\cos(ka)$' , linestyle = '--' , color = 'black' ) axs . set_yticks ([ eps - 2. * t , eps - t , eps , eps + t , eps + 2. * t ]) axs . set_yticklabels ([ '$\\epsilon_0-2t$' , '$\\epsilon_0-t$' , '$\\epsilon_0$' , '$\\epsilon_0+t$' , '$\\epsilon_0+2t$' ]) axs . set_xlabel ( 'k' ) axs . set_ylabel ( 'E(k)' ) axs . set_title ( f 'Modelo de tight-binding con cadena at\u00f3mica de N= { N } celdas (Cores: { num_cores } )' ) axs . legend () axs . grid ( True ) fig . savefig ( f 'tight_binding_cores_ { num_cores } .png' ) def main (): # Definir los argumentos de l\u00ednea de comandos parser = argparse . ArgumentParser ( description = 'Modelo de tight-binding en 1D' ) parser . add_argument ( '--cores' , type = int , default = cpu_count (), help = 'N\u00famero de n\u00facleos a utilizar' ) args = parser . parse_args () num_cores = args . cores # Par\u00e1metros N = 500 # N\u00famero de orbitales at\u00f3micos a = 1 # Espaciado de la red t = 0.5 # Par\u00e1metro de hopping eps = 0.0 # Energ\u00eda en el sitio max_iterations = 2 * N valores_k = np . linspace ( - np . pi / a , np . pi / a , max_iterations ) # Array de valores k # Medir el tiempo de ejecuci\u00f3n start_time = time . time () # Calcular la estructura de bandas autovalores = calcular_estructura_de_bandas ( N , a , t , eps , valores_k , num_cores ) # Seleccionar un conjunto arbitrario de autovalores para graficar autovalores_seleccionados = seleccionar_autovalores_aleatorios ( autovalores ) # Aplicar las condiciones de contorno peri\u00f3dicas autovalores_con_ccp = aplicar_condiciones_de_contorno_periodicas ( autovalores_seleccionados ) # Graficar la estructura de bandas graficar_estructura_de_bandas ( valores_k , autovalores_con_ccp , t , eps , a , N , num_cores ) # Calcular y mostrar el tiempo de ejecuci\u00f3n end_time = time . time () execution_time = end_time - start_time print ( f 'Tiempo de ejecuci\u00f3n: { execution_time } s' ) if __name__ == '__main__' : main () Despu\u00e9s de clonar el repositorio, puedes ejecutar los scripts de la siguiente manera: python tight_binding.py python tight_binding_parallel.py --cores 4","title":"Uso"},{"location":"uso/#uso","text":"Esta secci\u00f3n proporciona informaci\u00f3n sobre c\u00f3mo utilizar los scripts proporcionados.","title":"Uso"},{"location":"uso/#tight_bindingpy","text":"Este script implementa el modelo de Tight Binding de manera serial. import random import numpy as np import matplotlib.pyplot as plt def calcular_estructura_de_bandas ( N , a , t , eps , valores_k ): \"\"\" Calcula la estructura de bandas para un modelo de tight-binding en 1D. Par\u00e1metros: N (int): N\u00famero de orbitales at\u00f3micos. a (float): Espaciado de la red. t (float): Par\u00e1metro de hopping. eps (float): Energ\u00eda en el sitio. valores_k (np.ndarray): Array de valores de k. Retorna: lista de np.ndarray: Lista de arrays de autovalores para cada valor de k. \"\"\" autovalores = [] for k in valores_k : H = np . zeros (( N , N ), dtype = complex ) # T\u00e9rmino de energ\u00eda en el sitio for i in range ( N ): H [ i , i ] = eps # T\u00e9rminos de hopping con condiciones de contorno peri\u00f3dicas for i in range ( N ): H [ i , ( i + 1 ) % N ] = - t * np . exp ( 1 j * k * a ) H [( i + 1 ) % N , i ] = - t * np . exp ( - 1 j * k * a ) evals = np . linalg . eigvalsh ( H ) autovalores . append ( evals ) return autovalores def seleccionar_autovalores_aleatorios ( autovalores ): \"\"\" Selecciona un conjunto arbitrario de autovalores de la estructura de bandas calculada. Par\u00e1metros: autovalores (lista de np.ndarray): Lista de arrays de autovalores para cada valor de k. Retorna: np.ndarray: Array de autovalores seleccionados. \"\"\" indice_aleatorio = random . randint ( 0 , len ( autovalores ) - 1 ) return autovalores [ indice_aleatorio ] def aplicar_condiciones_de_contorno_periodicas ( autovalores ): \"\"\" Aplica condiciones de contorno peri\u00f3dicas de manera que E(-k) = E(k). Par\u00e1metros: autovalores (np.ndarray): Array de autovalores. Retorna: np.ndarray: Array de autovalores con condiciones de contorno peri\u00f3dicas aplicadas. \"\"\" return np . concatenate (( np . flip ( autovalores , 0 ), autovalores ), axis = 0 ) def calcular_banda_analitica ( valores_k , t , eps , a ): return eps - 2 * t * np . cos ( valores_k * a ) def graficar_estructura_de_bandas ( valores_k , banda_numerica , t , eps , a , N ): banda_analitica = calcular_banda_analitica ( valores_k , t , eps , a ) fig , axs = plt . subplots () axs . plot ( valores_k , banda_numerica , 'o' , label = f 'Autovalores de H(k)' ) axs . plot ( valores_k , banda_analitica , label = r '$E(k) = \\epsilon_0 - 2t\\cos(ka)$' , linestyle = '--' , color = 'black' ) axs . set_yticks ([ eps - 2. * t , eps - t , eps , eps + t , eps + 2. * t ]) axs . set_yticklabels ([ '$\\epsilon_0-2t$' , '$\\epsilon_0-t$' , '$\\epsilon_0$' , '$\\epsilon_0+t$' , '$\\epsilon_0+2t$' ]) axs . set_xlabel ( 'k' ) axs . set_ylabel ( 'E(k)' ) axs . set_title ( f 'Modelo de tight-binding con cadena at\u00f3mica de N= { N } celdas' ) axs . legend () axs . grid ( True ) fig . savefig ( 'tight_binding.png' ) # Par\u00e1metros N = 50 # N\u00famero de orbitales at\u00f3micos a = 1 # Espaciado de la red t = 0.5 # Par\u00e1metro de hopping eps = 0.0 # Energ\u00eda en el sitio max_iterations = 2 * N valores_k = np . linspace ( - np . pi / a , np . pi / a , max_iterations ) # Array de valores k # Calcular la estructura de bandas autovalores = calcular_estructura_de_bandas ( N , a , t , eps , valores_k ) # Seleccionar un conjunto arbitrario de autovalores para graficar autovalores_seleccionados = seleccionar_autovalores_aleatorios ( autovalores ) # Aplicar las condiciones de contorno peri\u00f3dicas autovalores_con_ccp = aplicar_condiciones_de_contorno_periodicas ( autovalores_seleccionados ) # Graficar la estructura de bandas graficar_estructura_de_bandas ( valores_k , autovalores_con_ccp , t , eps , a , N )","title":"tight_binding.py"},{"location":"uso/#tight_binding_parallelpy","text":"Este script implementa el modelo de Tight Binding de manera paralela utilizando multiprocessing. import random import numpy as np import matplotlib.pyplot as plt from multiprocessing import Pool , cpu_count import argparse import time def calcular_estructura_de_bandas_para_k ( args ): k , N , a , t , eps = args H = np . zeros (( N , N ), dtype = complex ) # T\u00e9rmino de energ\u00eda en el sitio for i in range ( N ): H [ i , i ] = eps # T\u00e9rminos de hopping con condiciones de contorno peri\u00f3dicas for i in range ( N ): H [ i , ( i + 1 ) % N ] = - t * np . exp ( 1 j * k * a ) H [( i + 1 ) % N , i ] = - t * np . exp ( - 1 j * k * a ) evals = np . linalg . eigvalsh ( H ) return evals def calcular_estructura_de_bandas ( N , a , t , eps , valores_k , num_cores ): \"\"\" Calcula la estructura de bandas para un modelo de tight-binding en 1D. Par\u00e1metros: N (int): N\u00famero de orbitales at\u00f3micos. a (float): Espaciado de la red. t (float): Par\u00e1metro de hopping. eps (float): Energ\u00eda en el sitio. valores_k (np.ndarray): Array de valores de k. num_cores (int): N\u00famero de n\u00facleos a utilizar para la paralelizaci\u00f3n. Retorna: lista de np.ndarray: Lista de arrays de autovalores para cada valor de k. \"\"\" with Pool ( num_cores ) as p : autovalores = p . map ( calcular_estructura_de_bandas_para_k , [( k , N , a , t , eps ) for k in valores_k ]) return autovalores def seleccionar_autovalores_aleatorios ( autovalores ): \"\"\" Selecciona un conjunto arbitrario de autovalores de la estructura de bandas calculada. Par\u00e1metros: autovalores (lista de np.ndarray): Lista de arrays de autovalores para cada valor de k. Retorna: np.ndarray: Array de autovalores seleccionados. \"\"\" indice_aleatorio = random . randint ( 0 , len ( autovalores ) - 1 ) return autovalores [ indice_aleatorio ] def aplicar_condiciones_de_contorno_periodicas ( autovalores ): \"\"\" Aplica condiciones de contorno peri\u00f3dicas de manera que E(-k) = E(k). Par\u00e1metros: autovalores (np.ndarray): Array de autovalores. Retorna: np.ndarray: Array de autovalores con condiciones de contorno peri\u00f3dicas aplicadas. \"\"\" return np . concatenate (( np . flip ( autovalores , 0 ), autovalores ), axis = 0 ) def calcular_banda_analitica ( valores_k , t , eps , a ): return eps - 2 * t * np . cos ( valores_k * a ) def graficar_estructura_de_bandas ( valores_k , banda_numerica , t , eps , a , N , num_cores ): banda_analitica = calcular_banda_analitica ( valores_k , t , eps , a ) fig , axs = plt . subplots () axs . plot ( valores_k , banda_numerica , 'o' , label = f 'Autovalores de H(k)' ) axs . plot ( valores_k , banda_analitica , label = r '$E(k) = \\epsilon_0 - 2t\\cos(ka)$' , linestyle = '--' , color = 'black' ) axs . set_yticks ([ eps - 2. * t , eps - t , eps , eps + t , eps + 2. * t ]) axs . set_yticklabels ([ '$\\epsilon_0-2t$' , '$\\epsilon_0-t$' , '$\\epsilon_0$' , '$\\epsilon_0+t$' , '$\\epsilon_0+2t$' ]) axs . set_xlabel ( 'k' ) axs . set_ylabel ( 'E(k)' ) axs . set_title ( f 'Modelo de tight-binding con cadena at\u00f3mica de N= { N } celdas (Cores: { num_cores } )' ) axs . legend () axs . grid ( True ) fig . savefig ( f 'tight_binding_cores_ { num_cores } .png' ) def main (): # Definir los argumentos de l\u00ednea de comandos parser = argparse . ArgumentParser ( description = 'Modelo de tight-binding en 1D' ) parser . add_argument ( '--cores' , type = int , default = cpu_count (), help = 'N\u00famero de n\u00facleos a utilizar' ) args = parser . parse_args () num_cores = args . cores # Par\u00e1metros N = 500 # N\u00famero de orbitales at\u00f3micos a = 1 # Espaciado de la red t = 0.5 # Par\u00e1metro de hopping eps = 0.0 # Energ\u00eda en el sitio max_iterations = 2 * N valores_k = np . linspace ( - np . pi / a , np . pi / a , max_iterations ) # Array de valores k # Medir el tiempo de ejecuci\u00f3n start_time = time . time () # Calcular la estructura de bandas autovalores = calcular_estructura_de_bandas ( N , a , t , eps , valores_k , num_cores ) # Seleccionar un conjunto arbitrario de autovalores para graficar autovalores_seleccionados = seleccionar_autovalores_aleatorios ( autovalores ) # Aplicar las condiciones de contorno peri\u00f3dicas autovalores_con_ccp = aplicar_condiciones_de_contorno_periodicas ( autovalores_seleccionados ) # Graficar la estructura de bandas graficar_estructura_de_bandas ( valores_k , autovalores_con_ccp , t , eps , a , N , num_cores ) # Calcular y mostrar el tiempo de ejecuci\u00f3n end_time = time . time () execution_time = end_time - start_time print ( f 'Tiempo de ejecuci\u00f3n: { execution_time } s' ) if __name__ == '__main__' : main () Despu\u00e9s de clonar el repositorio, puedes ejecutar los scripts de la siguiente manera: python tight_binding.py python tight_binding_parallel.py --cores 4","title":"tight_binding_parallel.py"}]}